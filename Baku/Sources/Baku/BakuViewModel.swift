import SwiftUI
import Combine
import Defaults

/// Main state for the Baku notch app
@MainActor
class BakuViewModel: ObservableObject {

    // MARK: - View State

    enum ViewState {
        case inbox
        case detail(Message)
    }

    enum NotchState {
        case closed
        case open
    }

    @Published var notchState: NotchState = .closed
    @Published var viewState: ViewState = .inbox
    @Published var isHovering: Bool = false

    // MARK: - Inbox State

    @Published var messages: [Message] = []
    @Published var isLoading: Bool = false
    @Published var lastFetchTime: Date?
    @Published var unreadCount: Int = 0
    @Published var errorMessage: String?

    // MARK: - Managers

    private let inboxManager = InboxManager.shared
    private let claudeManager = ClaudeManager.shared
    private let settings = SettingsManager.shared

    private var cancellables = Set<AnyCancellable>()

    // MARK: - Init

    init() {
        // Initialize managers and fetch real data
        Task {
            await inboxManager.initialize()
            await refresh()
        }
    }

    // MARK: - Computed Properties

    var isOpen: Bool {
        notchState == .open
    }

    var badgeText: String? {
        unreadCount > 0 ? "\(unreadCount)" : nil
    }

    var selectedMessage: Message? {
        if case .detail(let message) = viewState {
            return message
        }
        return nil
    }

    // MARK: - Navigation

    func selectMessage(_ message: Message) {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.85)) {
            viewState = .detail(message)
        }
    }

    func goBack() {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.85)) {
            viewState = .inbox
        }
    }

    // MARK: - Notch State

    func toggle() {
        withAnimation(.spring(response: 0.42, dampingFraction: 0.8)) {
            notchState = notchState == .open ? .closed : .open
        }
    }

    func open() {
        guard notchState != .open else { return }
        withAnimation(.spring(response: 0.42, dampingFraction: 0.8)) {
            notchState = .open
        }
    }

    func close() {
        guard notchState != .closed else { return }
        withAnimation(.spring(response: 0.45, dampingFraction: 1.0)) {
            notchState = .closed
        }
    }

    // MARK: - Data Fetching

    func refresh() async {
        isLoading = true
        errorMessage = nil

        do {
            // Fetch from connected platforms
            messages = try await inboxManager.fetchAll()

            // Auto-generate drafts if enabled
            if Defaults[.autoGenerateDrafts] && !messages.isEmpty {
                await generateAllDrafts()
            }

            unreadCount = messages.filter { !$0.isRead }.count
            lastFetchTime = Date()
        } catch {
            errorMessage = error.localizedDescription
        }

        isLoading = false
    }

    // MARK: - Draft Generation

    func generateDraft(for message: Message) async {
        guard let index = messages.firstIndex(where: { $0.id == message.id }) else { return }

        do {
            let tone = Draft.Tone(rawValue: Defaults[.draftTone]) ?? .professional
            let draft = try await claudeManager.generateDraft(for: message, tone: tone)
            messages[index].draft = draft

            // Update the detail view if showing this message
            if case .detail(let selectedMessage) = viewState, selectedMessage.id == message.id {
                viewState = .detail(messages[index])
            }
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    func generateAllDrafts() async {
        let drafts = await claudeManager.generateDrafts(for: messages)

        for (id, draft) in drafts {
            if let index = messages.firstIndex(where: { $0.id == id }) {
                messages[index].draft = draft
            }
        }
    }

    // MARK: - Sending Messages

    func sendReply(to message: Message, content: String) async throws {
        try await inboxManager.sendReply(to: message, content: content)

        // Mark as read and remove from list
        if let index = messages.firstIndex(where: { $0.id == message.id }) {
            messages[index].isRead = true
            unreadCount = messages.filter { !$0.isRead }.count
        }

        // Go back to inbox
        goBack()
    }

    // MARK: - Message Actions

    func markAsRead(_ message: Message) {
        if let index = messages.firstIndex(where: { $0.id == message.id }) {
            messages[index].isRead = true
            unreadCount = messages.filter { !$0.isRead }.count
        }
    }

    func dismissMessage(_ message: Message) {
        messages.removeAll { $0.id == message.id }
        unreadCount = messages.filter { !$0.isRead }.count

        if case .detail(let selectedMessage) = viewState, selectedMessage.id == message.id {
            goBack()
        }
    }
}
